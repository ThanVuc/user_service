// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: user.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getUserProfile = `-- name: GetUserProfile :one
SELECT
    u.id          AS user_id,
    u.fullname    AS fullname,
    u.email       AS email,
    u.avatar_url  AS avatar_url,
    u.bio         AS bio,
    u.slug        AS slug,
    u.date_of_birth AS date_of_birth,
    u.gender      AS gender,
    u.created_at  AS created_at,
    u.updated_at  AS updated_at,
    u.sentence    AS sentence,
    u.author      AS author
FROM users u
WHERE u.id = $1
`

type GetUserProfileRow struct {
	UserID      pgtype.UUID
	Fullname    pgtype.Text
	Email       string
	AvatarUrl   pgtype.Text
	Bio         pgtype.Text
	Slug        pgtype.Text
	DateOfBirth pgtype.Timestamptz
	Gender      pgtype.Bool
	CreatedAt   pgtype.Timestamptz
	UpdatedAt   pgtype.Timestamptz
	Sentence    pgtype.Text
	Author      pgtype.Text
}

func (q *Queries) GetUserProfile(ctx context.Context, id pgtype.UUID) (GetUserProfileRow, error) {
	row := q.db.QueryRow(ctx, getUserProfile, id)
	var i GetUserProfileRow
	err := row.Scan(
		&i.UserID,
		&i.Fullname,
		&i.Email,
		&i.AvatarUrl,
		&i.Bio,
		&i.Slug,
		&i.DateOfBirth,
		&i.Gender,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Sentence,
		&i.Author,
	)
	return i, err
}

const insertUser = `-- name: InsertUser :one
INSERT INTO users (id, email, fullname, created_at, updated_at)
VALUES ($1, NULLIF($2, ''), NULLIF($3, ''), $4, $5)
ON CONFLICT (id) DO UPDATE SET
    email = COALESCE(EXCLUDED.email, users.email),
    fullname = COALESCE(EXCLUDED.fullname, users.fullname),
    updated_at = EXCLUDED.updated_at
RETURNING id, email, fullname, created_at, updated_at
`

type InsertUserParams struct {
	ID        pgtype.UUID
	Column2   interface{}
	Column3   interface{}
	CreatedAt pgtype.Timestamptz
	UpdatedAt pgtype.Timestamptz
}

type InsertUserRow struct {
	ID        pgtype.UUID
	Email     string
	Fullname  pgtype.Text
	CreatedAt pgtype.Timestamptz
	UpdatedAt pgtype.Timestamptz
}

func (q *Queries) InsertUser(ctx context.Context, arg InsertUserParams) (InsertUserRow, error) {
	row := q.db.QueryRow(ctx, insertUser,
		arg.ID,
		arg.Column2,
		arg.Column3,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i InsertUserRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Fullname,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateAvatarById = `-- name: UpdateAvatarById :one
UPDATE users
SET avatar_url = $2,
    updated_at = NOW()
WHERE id = $1
RETURNING id
`

type UpdateAvatarByIdParams struct {
	ID        pgtype.UUID
	AvatarUrl pgtype.Text
}

func (q *Queries) UpdateAvatarById(ctx context.Context, arg UpdateAvatarByIdParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, updateAvatarById, arg.ID, arg.AvatarUrl)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const updateSlugById = `-- name: UpdateSlugById :one
UPDATE users
SET slug = $2
WHERE id = $1
RETURNING id
`

type UpdateSlugByIdParams struct {
	ID   pgtype.UUID
	Slug pgtype.Text
}

func (q *Queries) UpdateSlugById(ctx context.Context, arg UpdateSlugByIdParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, updateSlugById, arg.ID, arg.Slug)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const updateUserProfile = `-- name: UpdateUserProfile :one
UPDATE users
SET fullname      = $2,
    bio           = $3,
    date_of_birth = $4,
    gender        = $5,
    sentence      = $6,
    author        = $7,
    updated_at    = NOW()
WHERE id = $1
RETURNING id
`

type UpdateUserProfileParams struct {
	ID          pgtype.UUID
	Fullname    pgtype.Text
	Bio         pgtype.Text
	DateOfBirth pgtype.Timestamptz
	Gender      pgtype.Bool
	Sentence    pgtype.Text
	Author      pgtype.Text
}

func (q *Queries) UpdateUserProfile(ctx context.Context, arg UpdateUserProfileParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, updateUserProfile,
		arg.ID,
		arg.Fullname,
		arg.Bio,
		arg.DateOfBirth,
		arg.Gender,
		arg.Sentence,
		arg.Author,
	)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}
